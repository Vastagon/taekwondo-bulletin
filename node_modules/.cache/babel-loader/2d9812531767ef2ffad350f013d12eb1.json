{"ast":null,"code":"const fs = require('fs');\n\nconst {\n  extname,\n  basename\n} = require('path');\n\nconst Q = require('q');\n\nconst Writable = require(\"stream\").Writable;\n\nconst urlLib = require('url'); // eslint-disable-next-line import/order\n\n\nconst {\n  upload_prefix\n} = require(\"./config\")();\n\nconst isSecure = !(upload_prefix && upload_prefix.slice(0, 5) === 'http:');\nconst https = isSecure ? require('https') : require('http');\n\nconst Cache = require('./cache');\n\nconst utils = require(\"./utils\");\n\nconst UploadStream = require('./upload_stream');\n\nconst config = require(\"./config\");\n\nconst ProxyAgent = utils.optionalRequire('proxy-agent');\n\nconst ensureOption = require('./utils/ensureOption').defaults(config());\n\nconst {\n  build_upload_params,\n  extend,\n  includes,\n  isEmpty,\n  isObject,\n  isRemoteUrl,\n  merge,\n  pickOnlyExistingValues\n} = utils;\n\nexports.unsigned_upload_stream = function unsigned_upload_stream(upload_preset, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return exports.upload_stream(callback, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};\n\nexports.upload_stream = function upload_stream(callback) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return exports.upload(null, callback, extend({\n    stream: true\n  }, options));\n};\n\nexports.unsigned_upload = function unsigned_upload(file, upload_preset, callback) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return exports.upload(file, callback, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};\n\nexports.upload = function upload(file, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_api(\"upload\", callback, options, function () {\n    let params = build_upload_params(options);\n    return isRemoteUrl(file) ? [params, {\n      file: file\n    }] : [params, {}, file];\n  });\n};\n\nexports.upload_large = function upload_large(path, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (path != null && isRemoteUrl(path)) {\n    // upload a remote file\n    return exports.upload(path, callback, options);\n  }\n\n  if (path != null && !options.filename) {\n    options.filename = path.split(/(\\\\|\\/)/g).pop().replace(/\\.[^/.]+$/, \"\");\n  }\n\n  return exports.upload_chunked(path, callback, extend({\n    resource_type: 'raw'\n  }, options));\n};\n\nexports.upload_chunked = function upload_chunked(path, callback, options) {\n  let file_reader = fs.createReadStream(path);\n  let out_stream = exports.upload_chunked_stream(callback, options);\n  return file_reader.pipe(out_stream);\n};\n\nclass Chunkable extends Writable {\n  constructor(options) {\n    super(options);\n    this.chunk_size = options.chunk_size != null ? options.chunk_size : 20000000;\n    this.buffer = Buffer.alloc(0);\n    this.active = true;\n    this.on('finish', () => {\n      if (this.active) {\n        this.emit('ready', this.buffer, true, function () {});\n      }\n    });\n  }\n\n  _write(data, encoding, done) {\n    if (!this.active) {\n      done();\n    }\n\n    if (this.buffer.length + data.length <= this.chunk_size) {\n      this.buffer = Buffer.concat([this.buffer, data], this.buffer.length + data.length);\n      done();\n    } else {\n      const grab = this.chunk_size - this.buffer.length;\n      this.buffer = Buffer.concat([this.buffer, data.slice(0, grab)], this.buffer.length + grab);\n      this.emit('ready', this.buffer, false, active => {\n        this.active = active;\n\n        if (this.active) {\n          this.buffer = data.slice(grab);\n          done();\n        }\n      });\n    }\n  }\n\n}\n\nexports.upload_large_stream = function upload_large_stream(_unused_, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return exports.upload_chunked_stream(callback, extend({\n    resource_type: 'raw'\n  }, options));\n};\n\nexports.upload_chunked_stream = function upload_chunked_stream(callback) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = extend({}, options, {\n    stream: true\n  });\n  options.x_unique_upload_id = utils.random_public_id();\n  let params = build_upload_params(options);\n  let chunk_size = options.chunk_size != null ? options.chunk_size : options.part_size;\n  let chunker = new Chunkable({\n    chunk_size: chunk_size\n  });\n  let sent = 0;\n  chunker.on('ready', function (buffer, is_last, done) {\n    let chunk_start = sent;\n    sent += buffer.length;\n    options.content_range = `bytes ${chunk_start}-${sent - 1}/${is_last ? sent : -1}`;\n    params.timestamp = utils.timestamp();\n\n    let finished_part = function (result) {\n      const errorOrLast = result.error != null || is_last;\n\n      if (errorOrLast && typeof callback === \"function\") {\n        callback(result);\n      }\n\n      return done(!errorOrLast);\n    };\n\n    let stream = call_api(\"upload\", finished_part, options, function () {\n      return [params, {}, buffer];\n    });\n    return stream.write(buffer, 'buffer', function () {\n      return stream.end();\n    });\n  });\n  return chunker;\n};\n\nexports.explicit = function explicit(public_id, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_api(\"explicit\", callback, options, function () {\n    return utils.build_explicit_api_params(public_id, options);\n  });\n}; // Creates a new archive in the server and returns information in JSON format\n\n\nexports.create_archive = function create_archive(callback) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let target_format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return call_api(\"generate_archive\", callback, options, function () {\n    let opt = utils.archive_params(options);\n\n    if (target_format) {\n      opt.target_format = target_format;\n    }\n\n    return [opt];\n  });\n}; // Creates a new zip archive in the server and returns information in JSON format\n\n\nexports.create_zip = function create_zip(callback) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return exports.create_archive(callback, options, \"zip\");\n};\n\nexports.create_slideshow = function create_slideshow(options, callback) {\n  options.resource_type = ensureOption(options, \"resource_type\", \"video\");\n  return call_api(\"create_slideshow\", callback, options, function () {\n    // Generate a transformation from the manifest_transformation key, which should be a valid transformation\n    const manifest_transformation = utils.generate_transformation_string(extend({}, options.manifest_transformation)); // Try to use {options.transformation} to generate a transformation (Example: options.transformation.width, options.transformation.height)\n\n    const transformation = utils.generate_transformation_string(extend({}, ensureOption(options, 'transformation', {})));\n    return [{\n      timestamp: utils.timestamp(),\n      manifest_transformation: manifest_transformation,\n      upload_preset: options.upload_preset,\n      overwrite: options.overwrite,\n      public_id: options.public_id,\n      notification_url: options.notification_url,\n      manifest_json: options.manifest_json,\n      tags: options.tags,\n      transformation: transformation\n    }];\n  });\n};\n\nexports.destroy = function destroy(public_id, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_api(\"destroy\", callback, options, function () {\n    return [{\n      timestamp: utils.timestamp(),\n      type: options.type,\n      invalidate: options.invalidate,\n      public_id: public_id\n    }];\n  });\n};\n\nexports.rename = function rename(from_public_id, to_public_id, callback) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return call_api(\"rename\", callback, options, function () {\n    return [{\n      timestamp: utils.timestamp(),\n      type: options.type,\n      from_public_id: from_public_id,\n      to_public_id: to_public_id,\n      overwrite: options.overwrite,\n      invalidate: options.invalidate,\n      to_type: options.to_type\n    }];\n  });\n};\n\nconst TEXT_PARAMS = [\"public_id\", \"font_family\", \"font_size\", \"font_color\", \"text_align\", \"font_weight\", \"font_style\", \"background\", \"opacity\", \"text_decoration\", \"font_hinting\", \"font_antialiasing\"];\n\nexports.text = function text(content, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_api(\"text\", callback, options, function () {\n    let textParams = pickOnlyExistingValues(options, ...TEXT_PARAMS);\n    let params = {\n      timestamp: utils.timestamp(),\n      text: content,\n      ...textParams\n    };\n    return [params];\n  });\n};\n/**\n * Generate a sprite by merging multiple images into a single large image for reducing network overhead and bypassing\n * download limitations.\n *\n * The process produces 2 files as follows:\n * - A single image file containing all the images with the specified tag (PNG by default).\n * - A CSS file that includes the style class names and the location of the individual images in the sprite.\n *\n * @param {String|Object} tag     A string specifying a tag that indicates which images to include or an object\n *                                which includes options and image URLs.\n * @param {Function}     callback   Callback function\n * @param {Object}       options  Configuration options. If options are passed as the first parameter, this parameter\n *                                should be empty\n *\n * @return {Object}\n */\n\n\nexports.generate_sprite = function generate_sprite(tag, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_api(\"sprite\", callback, options, function () {\n    return [utils.build_multi_and_sprite_params(tag, options)];\n  });\n};\n/**\n * Returns a signed url to download a sprite\n *\n * @param {String|Object} tag     A string specifying a tag that indicates which images to include or an object\n *                                which includes options and image URLs.\n * @param {Object}       options  Configuration options. If options are passed as the first parameter, this parameter\n *                                should be empty\n *\n * @returns {string}\n */\n\n\nexports.download_generated_sprite = function download_generated_sprite(tag) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return utils.api_download_url(\"sprite\", utils.build_multi_and_sprite_params(tag, options), options);\n};\n/**\n * Returns a signed url to download a single animated image (GIF, PNG or WebP), video (MP4 or WebM) or a single PDF from\n * multiple image assets.\n *\n * @param {String|Object} tag     A string specifying a tag that indicates which images to include or an object\n *                                which includes options and image URLs.\n * @param {Object}       options  Configuration options. If options are passed as the first parameter, this parameter\n *                                should be empty\n *\n * @returns {string}\n */\n\n\nexports.download_multi = function download_multi(tag) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return utils.api_download_url(\"multi\", utils.build_multi_and_sprite_params(tag, options), options);\n};\n/**\n * Creates either a single animated image (GIF, PNG or WebP), video (MP4 or WebM) or a single PDF from multiple image\n * assets.\n *\n * Each asset is included as a single frame of the resulting animated image/video, or a page of the PDF (sorted\n * alphabetically by their Public ID).\n *\n * @param {String|Object} tag     A string specifying a tag that indicates which images to include or an object\n *                                which includes options and image URLs.\n * @param {Function}     callback   Callback function\n * @param {Object}       options  Configuration options. If options are passed as the first parameter, this parameter\n *                                should be empty\n *\n * @return {Object}\n */\n\n\nexports.multi = function multi(tag, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_api(\"multi\", callback, options, function () {\n    return [utils.build_multi_and_sprite_params(tag, options)];\n  });\n};\n\nexports.explode = function explode(public_id, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_api(\"explode\", callback, options, function () {\n    const transformation = utils.generate_transformation_string(extend({}, options));\n    return [{\n      timestamp: utils.timestamp(),\n      public_id: public_id,\n      transformation: transformation,\n      format: options.format,\n      type: options.type,\n      notification_url: options.notification_url\n    }];\n  });\n};\n/**\n *\n * @param {String}          tag                  The tag or tags to assign. Can specify multiple\n *                                               tags in a single string, separated by commas - \"t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11\".\n *\n * @param {Array}          public_ids           A list of public IDs (up to 1000) of assets uploaded to Cloudinary.\n *\n * @param {Function}        callback             Callback function\n *\n * @param {Object}          options              Configuration options may include 'exclusive' (boolean) which causes\n *                                               clearing this tag from all other resources\n * @return {Object}\n */\n\n\nexports.add_tag = function add_tag(tag) {\n  let public_ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let callback = arguments.length > 2 ? arguments[2] : undefined;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const exclusive = utils.option_consume(\"exclusive\", options);\n  const command = exclusive ? \"set_exclusive\" : \"add\";\n  return call_tags_api(tag, command, public_ids, callback, options);\n};\n/**\n * @param {String}          tag                  The tag or tags to remove. Can specify multiple\n *                                               tags in a single string, separated by commas - \"t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11\".\n *\n * @param {Array}          public_ids            A list of public IDs (up to 1000) of assets uploaded to Cloudinary.\n *\n * @param {Function}        callback             Callback function\n *\n * @param {Object}          options              Configuration options may include 'exclusive' (boolean) which causes\n *                                               clearing this tag from all other resources\n * @return {Object}\n */\n\n\nexports.remove_tag = function remove_tag(tag) {\n  let public_ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let callback = arguments.length > 2 ? arguments[2] : undefined;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return call_tags_api(tag, \"remove\", public_ids, callback, options);\n};\n\nexports.remove_all_tags = function remove_all_tags() {\n  let public_ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let callback = arguments.length > 1 ? arguments[1] : undefined;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_tags_api(null, \"remove_all\", public_ids, callback, options);\n};\n\nexports.replace_tag = function replace_tag(tag) {\n  let public_ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let callback = arguments.length > 2 ? arguments[2] : undefined;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return call_tags_api(tag, \"replace\", public_ids, callback, options);\n};\n\nfunction call_tags_api(tag, command) {\n  let public_ids = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let callback = arguments.length > 3 ? arguments[3] : undefined;\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  return call_api(\"tags\", callback, options, function () {\n    let params = {\n      timestamp: utils.timestamp(),\n      public_ids: utils.build_array(public_ids),\n      command: command,\n      type: options.type\n    };\n\n    if (tag != null) {\n      params.tag = tag;\n    }\n\n    return [params];\n  });\n}\n\nexports.add_context = function add_context(context) {\n  let public_ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let callback = arguments.length > 2 ? arguments[2] : undefined;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return call_context_api(context, 'add', public_ids, callback, options);\n};\n\nexports.remove_all_context = function remove_all_context() {\n  let public_ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let callback = arguments.length > 1 ? arguments[1] : undefined;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return call_context_api(null, 'remove_all', public_ids, callback, options);\n};\n\nfunction call_context_api(context, command) {\n  let public_ids = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let callback = arguments.length > 3 ? arguments[3] : undefined;\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  return call_api('context', callback, options, function () {\n    let params = {\n      timestamp: utils.timestamp(),\n      public_ids: utils.build_array(public_ids),\n      command: command,\n      type: options.type\n    };\n\n    if (context != null) {\n      params.context = utils.encode_context(context);\n    }\n\n    return [params];\n  });\n}\n/**\n * Cache (part of) the upload results.\n * @param result\n * @param {object} options\n * @param {string} options.type\n * @param {string} options.resource_type\n */\n\n\nfunction cacheResults(result, _ref) {\n  let {\n    type,\n    resource_type\n  } = _ref;\n\n  if (result.responsive_breakpoints) {\n    result.responsive_breakpoints.forEach(_ref2 => {\n      let {\n        transformation,\n        url,\n        breakpoints\n      } = _ref2;\n      return Cache.set(result.public_id, {\n        type,\n        resource_type,\n        raw_transformation: transformation,\n        format: extname(breakpoints[0].url).slice(1)\n      }, breakpoints.map(i => i.width));\n    });\n  }\n}\n\nfunction parseResult(buffer, res) {\n  let result = '';\n\n  try {\n    result = JSON.parse(buffer);\n\n    if (result.error && !result.error.name) {\n      result.error.name = \"Error\";\n    }\n  } catch (jsonError) {\n    result = {\n      error: {\n        message: `Server return invalid JSON response. Status Code ${res.statusCode}. ${jsonError}`,\n        name: \"Error\"\n      }\n    };\n  }\n\n  return result;\n}\n\nfunction call_api(action, callback, options, get_params) {\n  if (typeof callback !== \"function\") {\n    callback = function () {};\n  }\n\n  const USE_PROMISES = !options.disable_promises;\n  let deferred = Q.defer();\n\n  if (options == null) {\n    options = {};\n  }\n\n  let [params, unsigned_params, file] = get_params.call();\n  params = utils.process_request_params(params, options);\n  params = extend(params, unsigned_params);\n  let api_url = utils.api_url(action, options);\n  let boundary = utils.random_public_id();\n  let errorRaised = false;\n\n  let handle_response = function (res) {\n    // let buffer;\n    if (errorRaised) {// Already reported\n    } else if (res.error) {\n      errorRaised = true;\n\n      if (USE_PROMISES) {\n        deferred.reject(res);\n      }\n\n      callback(res);\n    } else if (includes([200, 400, 401, 404, 420, 500], res.statusCode)) {\n      let buffer = \"\";\n      res.on(\"data\", d => {\n        buffer += d;\n        return buffer;\n      });\n      res.on(\"end\", () => {\n        let result;\n\n        if (errorRaised) {\n          return;\n        }\n\n        result = parseResult(buffer, res);\n\n        if (result.error) {\n          result.error.http_code = res.statusCode;\n\n          if (USE_PROMISES) {\n            deferred.reject(result.error);\n          }\n        } else {\n          cacheResults(result, options);\n\n          if (USE_PROMISES) {\n            deferred.resolve(result);\n          }\n        }\n\n        callback(result);\n      });\n      res.on(\"error\", error => {\n        errorRaised = true;\n\n        if (USE_PROMISES) {\n          deferred.reject(error);\n        }\n\n        callback({\n          error\n        });\n      });\n    } else {\n      let error = {\n        message: `Server returned unexpected status code - ${res.statusCode}`,\n        http_code: res.statusCode,\n        name: \"UnexpectedResponse\"\n      };\n\n      if (USE_PROMISES) {\n        deferred.reject(error);\n      }\n\n      callback({\n        error\n      });\n    }\n  };\n\n  let post_data = utils.hashToParameters(params).filter(_ref3 => {\n    let [key, value] = _ref3;\n    return value != null;\n  }).map(_ref4 => {\n    let [key, value] = _ref4;\n    return Buffer.from(encodeFieldPart(boundary, key, value), 'utf8');\n  });\n  let result = post(api_url, post_data, boundary, file, handle_response, options);\n\n  if (isObject(result)) {\n    return result;\n  }\n\n  if (USE_PROMISES) {\n    return deferred.promise;\n  }\n}\n\nfunction post(url, post_data, boundary, file, callback, options) {\n  let file_header;\n  let finish_buffer = Buffer.from(\"--\" + boundary + \"--\", 'ascii');\n  let oauth_token = options.oauth_token || config().oauth_token;\n\n  if (file != null || options.stream) {\n    // eslint-disable-next-line no-nested-ternary\n    let filename = options.stream ? options.filename ? options.filename : \"file\" : basename(file);\n    file_header = Buffer.from(encodeFilePart(boundary, 'application/octet-stream', 'file', filename), 'binary');\n  }\n\n  let post_options = urlLib.parse(url);\n  let headers = {\n    'Content-Type': `multipart/form-data; boundary=${boundary}`,\n    'User-Agent': utils.getUserAgent()\n  };\n\n  if (options.content_range != null) {\n    headers['Content-Range'] = options.content_range;\n  }\n\n  if (options.x_unique_upload_id != null) {\n    headers['X-Unique-Upload-Id'] = options.x_unique_upload_id;\n  }\n\n  if (oauth_token != null) {\n    headers.Authorization = `Bearer ${oauth_token}`;\n  }\n\n  post_options = extend(post_options, {\n    method: 'POST',\n    headers: headers\n  });\n\n  if (options.agent != null) {\n    post_options.agent = options.agent;\n  }\n\n  let proxy = options.api_proxy || config().api_proxy;\n\n  if (!isEmpty(proxy)) {\n    if (!post_options.agent) {\n      if (ProxyAgent === null) {\n        throw new Error(\"Proxy value is set, but `proxy-agent` is not installed, please install `proxy-agent` module.\");\n      }\n\n      post_options.agent = new ProxyAgent(proxy);\n    } else {\n      console.warn(\"Proxy is set, but request uses a custom agent, proxy is ignored.\");\n    }\n  }\n\n  let post_request = https.request(post_options, callback);\n  let upload_stream = new UploadStream({\n    boundary\n  });\n  upload_stream.pipe(post_request);\n  let timeout = false;\n  post_request.on(\"error\", function (error) {\n    if (timeout) {\n      error = {\n        message: \"Request Timeout\",\n        http_code: 499,\n        name: \"TimeoutError\"\n      };\n    }\n\n    return callback({\n      error\n    });\n  });\n  post_request.setTimeout(options.timeout != null ? options.timeout : 60000, function () {\n    timeout = true;\n    return post_request.abort();\n  });\n  post_data.forEach(postDatum => post_request.write(postDatum));\n\n  if (options.stream) {\n    post_request.write(file_header);\n    return upload_stream;\n  }\n\n  if (file != null) {\n    post_request.write(file_header);\n    fs.createReadStream(file).on('error', function (error) {\n      callback({\n        error: error\n      });\n      return post_request.abort();\n    }).pipe(upload_stream);\n  } else {\n    post_request.write(finish_buffer);\n    post_request.end();\n  }\n\n  return true;\n}\n\nfunction encodeFieldPart(boundary, name, value) {\n  return [`--${boundary}`, `Content-Disposition: form-data; name=\"${name}\"`, '', value, ''].join(\"\\r\\n\");\n}\n\nfunction encodeFilePart(boundary, type, name, filename) {\n  return [`--${boundary}`, `Content-Disposition: form-data; name=\"${name}\"; filename=\"${filename}\"`, `Content-Type: ${type}`, '', ''].join(\"\\r\\n\");\n}\n\nexports.direct_upload = function direct_upload(callback_url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let params = build_upload_params(extend({\n    callback: callback_url\n  }, options));\n  params = utils.process_request_params(params, options);\n  let api_url = utils.api_url(\"upload\", options);\n  return {\n    hidden_fields: params,\n    form_attrs: {\n      action: api_url,\n      method: \"POST\",\n      enctype: \"multipart/form-data\"\n    }\n  };\n};\n\nexports.upload_tag_params = function upload_tag_params() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let params = build_upload_params(options);\n  params = utils.process_request_params(params, options);\n  return JSON.stringify(params);\n};\n\nexports.upload_url = function upload_url() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (options.resource_type == null) {\n    options.resource_type = \"auto\";\n  }\n\n  return utils.api_url(\"upload\", options);\n};\n\nexports.image_upload_tag = function image_upload_tag(field) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let html_options = options.html || {};\n  let tag_options = extend({\n    type: \"file\",\n    name: \"file\",\n    \"data-url\": exports.upload_url(options),\n    \"data-form-data\": exports.upload_tag_params(options),\n    \"data-cloudinary-field\": field,\n    \"data-max-chunk-size\": options.chunk_size,\n    \"class\": [html_options.class, \"cloudinary-fileupload\"].join(\" \")\n  }, html_options);\n  return `<input ${utils.html_attrs(tag_options)}/>`;\n};\n\nexports.unsigned_image_upload_tag = function unsigned_image_upload_tag(field, upload_preset) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return exports.image_upload_tag(field, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};\n/**\n * Populates metadata fields with the given values. Existing values will be overwritten.\n *\n * @param {Object}   metadata   A list of custom metadata fields (by external_id) and the values to assign to each\n * @param {Array}    public_ids The public IDs of the resources to update\n * @param {Function} callback   Callback function\n * @param {Object}   options    Configuration options\n *\n * @return {Object}\n */\n\n\nexports.update_metadata = function update_metadata(metadata, public_ids, callback) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return call_api(\"metadata\", callback, options, function () {\n    let params = {\n      metadata: utils.encode_context(metadata),\n      public_ids: utils.build_array(public_ids),\n      timestamp: utils.timestamp(),\n      type: options.type\n    };\n    return [params];\n  });\n};","map":{"version":3,"sources":["/home/jacob/Code/taekwondo-bulletin/node_modules/cloudinary/lib/uploader.js"],"names":["fs","require","extname","basename","Q","Writable","urlLib","upload_prefix","isSecure","slice","https","Cache","utils","UploadStream","config","ProxyAgent","optionalRequire","ensureOption","defaults","build_upload_params","extend","includes","isEmpty","isObject","isRemoteUrl","merge","pickOnlyExistingValues","exports","unsigned_upload_stream","upload_preset","callback","options","upload_stream","unsigned","upload","stream","unsigned_upload","file","call_api","params","upload_large","path","filename","split","pop","replace","upload_chunked","resource_type","file_reader","createReadStream","out_stream","upload_chunked_stream","pipe","Chunkable","constructor","chunk_size","buffer","Buffer","alloc","active","on","emit","_write","data","encoding","done","length","concat","grab","upload_large_stream","_unused_","x_unique_upload_id","random_public_id","part_size","chunker","sent","is_last","chunk_start","content_range","timestamp","finished_part","result","errorOrLast","error","write","end","explicit","public_id","build_explicit_api_params","create_archive","target_format","opt","archive_params","create_zip","create_slideshow","manifest_transformation","generate_transformation_string","transformation","overwrite","notification_url","manifest_json","tags","destroy","type","invalidate","rename","from_public_id","to_public_id","to_type","TEXT_PARAMS","text","content","textParams","generate_sprite","tag","build_multi_and_sprite_params","download_generated_sprite","api_download_url","download_multi","multi","explode","format","add_tag","public_ids","exclusive","option_consume","command","call_tags_api","remove_tag","remove_all_tags","replace_tag","build_array","add_context","context","call_context_api","remove_all_context","encode_context","cacheResults","responsive_breakpoints","forEach","url","breakpoints","set","raw_transformation","map","i","width","parseResult","res","JSON","parse","name","jsonError","message","statusCode","action","get_params","USE_PROMISES","disable_promises","deferred","defer","unsigned_params","call","process_request_params","api_url","boundary","errorRaised","handle_response","reject","d","http_code","resolve","post_data","hashToParameters","filter","key","value","from","encodeFieldPart","post","promise","file_header","finish_buffer","oauth_token","encodeFilePart","post_options","headers","getUserAgent","Authorization","method","agent","proxy","api_proxy","Error","console","warn","post_request","request","timeout","setTimeout","abort","postDatum","join","direct_upload","callback_url","hidden_fields","form_attrs","enctype","upload_tag_params","stringify","upload_url","image_upload_tag","field","html_options","html","tag_options","class","html_attrs","unsigned_image_upload_tag","update_metadata","metadata"],"mappings":"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","sourcesContent":["const fs = require('fs');\nconst { extname, basename } = require('path');\nconst Q = require('q');\nconst Writable = require(\"stream\").Writable;\nconst urlLib = require('url');\n\n// eslint-disable-next-line import/order\nconst { upload_prefix } = require(\"./config\")();\n\nconst isSecure = !(upload_prefix && upload_prefix.slice(0, 5) === 'http:');\nconst https = isSecure ? require('https') : require('http');\n\nconst Cache = require('./cache');\nconst utils = require(\"./utils\");\nconst UploadStream = require('./upload_stream');\nconst config = require(\"./config\");\nconst ProxyAgent = utils.optionalRequire('proxy-agent');\nconst ensureOption = require('./utils/ensureOption').defaults(config());\n\nconst {\n  build_upload_params,\n  extend,\n  includes,\n  isEmpty,\n  isObject,\n  isRemoteUrl,\n  merge,\n  pickOnlyExistingValues\n} = utils;\n\nexports.unsigned_upload_stream = function unsigned_upload_stream(upload_preset, callback, options = {}) {\n  return exports.upload_stream(callback, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};\n\nexports.upload_stream = function upload_stream(callback, options = {}) {\n  return exports.upload(null, callback, extend({\n    stream: true\n  }, options));\n};\n\nexports.unsigned_upload = function unsigned_upload(file, upload_preset, callback, options = {}) {\n  return exports.upload(file, callback, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};\n\nexports.upload = function upload(file, callback, options = {}) {\n  return call_api(\"upload\", callback, options, function () {\n    let params = build_upload_params(options);\n    return isRemoteUrl(file) ? [params, { file: file }] : [params, {}, file];\n  });\n};\n\nexports.upload_large = function upload_large(path, callback, options = {}) {\n  if ((path != null) && isRemoteUrl(path)) {\n    // upload a remote file\n    return exports.upload(path, callback, options);\n  }\n  if (path != null && !options.filename) {\n    options.filename = path.split(/(\\\\|\\/)/g).pop().replace(/\\.[^/.]+$/, \"\");\n  }\n  return exports.upload_chunked(path, callback, extend({\n    resource_type: 'raw'\n  }, options));\n};\n\nexports.upload_chunked = function upload_chunked(path, callback, options) {\n  let file_reader = fs.createReadStream(path);\n  let out_stream = exports.upload_chunked_stream(callback, options);\n  return file_reader.pipe(out_stream);\n};\n\nclass Chunkable extends Writable {\n  constructor(options) {\n    super(options);\n    this.chunk_size = options.chunk_size != null ? options.chunk_size : 20000000;\n    this.buffer = Buffer.alloc(0);\n    this.active = true;\n    this.on('finish', () => {\n      if (this.active) {\n        this.emit('ready', this.buffer, true, function () {\n        });\n      }\n    });\n  }\n\n  _write(data, encoding, done) {\n    if (!this.active) {\n      done();\n    }\n    if (this.buffer.length + data.length <= this.chunk_size) {\n      this.buffer = Buffer.concat([this.buffer, data], this.buffer.length + data.length);\n      done();\n    } else {\n      const grab = this.chunk_size - this.buffer.length;\n      this.buffer = Buffer.concat([this.buffer, data.slice(0, grab)], this.buffer.length + grab);\n      this.emit('ready', this.buffer, false, (active) => {\n        this.active = active;\n        if (this.active) {\n          this.buffer = data.slice(grab);\n          done();\n        }\n      });\n    }\n  }\n}\n\nexports.upload_large_stream = function upload_large_stream(_unused_, callback, options = {}) {\n  return exports.upload_chunked_stream(callback, extend({\n    resource_type: 'raw'\n  }, options));\n};\n\nexports.upload_chunked_stream = function upload_chunked_stream(callback, options = {}) {\n  options = extend({}, options, {\n    stream: true\n  });\n  options.x_unique_upload_id = utils.random_public_id();\n  let params = build_upload_params(options);\n  let chunk_size = options.chunk_size != null ? options.chunk_size : options.part_size;\n  let chunker = new Chunkable({\n    chunk_size: chunk_size\n  });\n  let sent = 0;\n  chunker.on('ready', function (buffer, is_last, done) {\n    let chunk_start = sent;\n    sent += buffer.length;\n    options.content_range = `bytes ${chunk_start}-${sent - 1}/${(is_last ? sent : -1)}`;\n    params.timestamp = utils.timestamp();\n    let finished_part = function (result) {\n      const errorOrLast = (result.error != null) || is_last;\n      if (errorOrLast && typeof callback === \"function\") {\n        callback(result);\n      }\n      return done(!errorOrLast);\n    };\n    let stream = call_api(\"upload\", finished_part, options, function () {\n      return [params, {}, buffer];\n    });\n    return stream.write(buffer, 'buffer', function () {\n      return stream.end();\n    });\n  });\n  return chunker;\n};\n\nexports.explicit = function explicit(public_id, callback, options = {}) {\n  return call_api(\"explicit\", callback, options, function () {\n    return utils.build_explicit_api_params(public_id, options);\n  });\n};\n\n// Creates a new archive in the server and returns information in JSON format\nexports.create_archive = function create_archive(callback, options = {}, target_format = null) {\n  return call_api(\"generate_archive\", callback, options, function () {\n    let opt = utils.archive_params(options);\n    if (target_format) {\n      opt.target_format = target_format;\n    }\n    return [opt];\n  });\n};\n\n// Creates a new zip archive in the server and returns information in JSON format\nexports.create_zip = function create_zip(callback, options = {}) {\n  return exports.create_archive(callback, options, \"zip\");\n};\n\n\nexports.create_slideshow = function create_slideshow(options, callback) {\n  options.resource_type = ensureOption(options, \"resource_type\", \"video\");\n  return call_api(\"create_slideshow\", callback, options, function () {\n    // Generate a transformation from the manifest_transformation key, which should be a valid transformation\n    const manifest_transformation = utils.generate_transformation_string(extend({}, options.manifest_transformation));\n\n    // Try to use {options.transformation} to generate a transformation (Example: options.transformation.width, options.transformation.height)\n    const transformation = utils.generate_transformation_string(extend({}, ensureOption(options, 'transformation', {})));\n\n    return [\n      {\n        timestamp: utils.timestamp(),\n        manifest_transformation: manifest_transformation,\n        upload_preset: options.upload_preset,\n        overwrite: options.overwrite,\n        public_id: options.public_id,\n        notification_url: options.notification_url,\n        manifest_json: options.manifest_json,\n        tags: options.tags,\n        transformation: transformation\n      }\n    ];\n  });\n};\n\n\nexports.destroy = function destroy(public_id, callback, options = {}) {\n  return call_api(\"destroy\", callback, options, function () {\n    return [\n      {\n        timestamp: utils.timestamp(),\n        type: options.type,\n        invalidate: options.invalidate,\n        public_id: public_id\n      }\n    ];\n  });\n};\n\nexports.rename = function rename(from_public_id, to_public_id, callback, options = {}) {\n  return call_api(\"rename\", callback, options, function () {\n    return [\n      {\n        timestamp: utils.timestamp(),\n        type: options.type,\n        from_public_id: from_public_id,\n        to_public_id: to_public_id,\n        overwrite: options.overwrite,\n        invalidate: options.invalidate,\n        to_type: options.to_type\n      }\n    ];\n  });\n};\n\nconst TEXT_PARAMS = [\"public_id\", \"font_family\", \"font_size\", \"font_color\", \"text_align\", \"font_weight\", \"font_style\", \"background\", \"opacity\", \"text_decoration\", \"font_hinting\", \"font_antialiasing\"];\n\nexports.text = function text(content, callback, options = {}) {\n  return call_api(\"text\", callback, options, function () {\n    let textParams = pickOnlyExistingValues(options, ...TEXT_PARAMS);\n    let params = {\n      timestamp: utils.timestamp(),\n      text: content,\n      ...textParams\n    };\n\n    return [params];\n  });\n};\n\n/**\n * Generate a sprite by merging multiple images into a single large image for reducing network overhead and bypassing\n * download limitations.\n *\n * The process produces 2 files as follows:\n * - A single image file containing all the images with the specified tag (PNG by default).\n * - A CSS file that includes the style class names and the location of the individual images in the sprite.\n *\n * @param {String|Object} tag     A string specifying a tag that indicates which images to include or an object\n *                                which includes options and image URLs.\n * @param {Function}     callback   Callback function\n * @param {Object}       options  Configuration options. If options are passed as the first parameter, this parameter\n *                                should be empty\n *\n * @return {Object}\n */\nexports.generate_sprite = function generate_sprite(tag, callback, options = {}) {\n  return call_api(\"sprite\", callback, options, function () {\n    return [utils.build_multi_and_sprite_params(tag, options)];\n  });\n};\n\n\n/**\n * Returns a signed url to download a sprite\n *\n * @param {String|Object} tag     A string specifying a tag that indicates which images to include or an object\n *                                which includes options and image URLs.\n * @param {Object}       options  Configuration options. If options are passed as the first parameter, this parameter\n *                                should be empty\n *\n * @returns {string}\n */\nexports.download_generated_sprite = function download_generated_sprite(tag, options = {}) {\n  return utils.api_download_url(\"sprite\", utils.build_multi_and_sprite_params(tag, options), options);\n}\n\n/**\n * Returns a signed url to download a single animated image (GIF, PNG or WebP), video (MP4 or WebM) or a single PDF from\n * multiple image assets.\n *\n * @param {String|Object} tag     A string specifying a tag that indicates which images to include or an object\n *                                which includes options and image URLs.\n * @param {Object}       options  Configuration options. If options are passed as the first parameter, this parameter\n *                                should be empty\n *\n * @returns {string}\n */\nexports.download_multi = function download_multi(tag, options = {}) {\n  return utils.api_download_url(\"multi\", utils.build_multi_and_sprite_params(tag, options), options);\n}\n\n/**\n * Creates either a single animated image (GIF, PNG or WebP), video (MP4 or WebM) or a single PDF from multiple image\n * assets.\n *\n * Each asset is included as a single frame of the resulting animated image/video, or a page of the PDF (sorted\n * alphabetically by their Public ID).\n *\n * @param {String|Object} tag     A string specifying a tag that indicates which images to include or an object\n *                                which includes options and image URLs.\n * @param {Function}     callback   Callback function\n * @param {Object}       options  Configuration options. If options are passed as the first parameter, this parameter\n *                                should be empty\n *\n * @return {Object}\n */\nexports.multi = function multi(tag, callback, options = {}) {\n  return call_api(\"multi\", callback, options, function () {\n    return [utils.build_multi_and_sprite_params(tag, options)];\n  });\n};\n\nexports.explode = function explode(public_id, callback, options = {}) {\n  return call_api(\"explode\", callback, options, function () {\n    const transformation = utils.generate_transformation_string(extend({}, options));\n    return [\n      {\n        timestamp: utils.timestamp(),\n        public_id: public_id,\n        transformation: transformation,\n        format: options.format,\n        type: options.type,\n        notification_url: options.notification_url\n      }\n    ];\n  });\n};\n\n/**\n *\n * @param {String}          tag                  The tag or tags to assign. Can specify multiple\n *                                               tags in a single string, separated by commas - \"t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11\".\n *\n * @param {Array}          public_ids           A list of public IDs (up to 1000) of assets uploaded to Cloudinary.\n *\n * @param {Function}        callback             Callback function\n *\n * @param {Object}          options              Configuration options may include 'exclusive' (boolean) which causes\n *                                               clearing this tag from all other resources\n * @return {Object}\n */\nexports.add_tag = function add_tag(tag, public_ids = [], callback, options = {}) {\n  const exclusive = utils.option_consume(\"exclusive\", options);\n  const command = exclusive ? \"set_exclusive\" : \"add\";\n  return call_tags_api(tag, command, public_ids, callback, options);\n};\n\n\n/**\n * @param {String}          tag                  The tag or tags to remove. Can specify multiple\n *                                               tags in a single string, separated by commas - \"t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11\".\n *\n * @param {Array}          public_ids            A list of public IDs (up to 1000) of assets uploaded to Cloudinary.\n *\n * @param {Function}        callback             Callback function\n *\n * @param {Object}          options              Configuration options may include 'exclusive' (boolean) which causes\n *                                               clearing this tag from all other resources\n * @return {Object}\n */\nexports.remove_tag = function remove_tag(tag, public_ids = [], callback, options = {}) {\n  return call_tags_api(tag, \"remove\", public_ids, callback, options);\n};\n\nexports.remove_all_tags = function remove_all_tags(public_ids = [], callback, options = {}) {\n  return call_tags_api(null, \"remove_all\", public_ids, callback, options);\n};\n\nexports.replace_tag = function replace_tag(tag, public_ids = [], callback, options = {}) {\n  return call_tags_api(tag, \"replace\", public_ids, callback, options);\n};\n\nfunction call_tags_api(tag, command, public_ids = [], callback, options = {}) {\n  return call_api(\"tags\", callback, options, function () {\n    let params = {\n      timestamp: utils.timestamp(),\n      public_ids: utils.build_array(public_ids),\n      command: command,\n      type: options.type\n    };\n    if (tag != null) {\n      params.tag = tag;\n    }\n    return [params];\n  });\n}\n\nexports.add_context = function add_context(context, public_ids = [], callback, options = {}) {\n  return call_context_api(context, 'add', public_ids, callback, options);\n};\n\nexports.remove_all_context = function remove_all_context(public_ids = [], callback, options = {}) {\n  return call_context_api(null, 'remove_all', public_ids, callback, options);\n};\n\nfunction call_context_api(context, command, public_ids = [], callback, options = {}) {\n  return call_api('context', callback, options, function () {\n    let params = {\n      timestamp: utils.timestamp(),\n      public_ids: utils.build_array(public_ids),\n      command: command,\n      type: options.type\n    };\n    if (context != null) {\n      params.context = utils.encode_context(context);\n    }\n    return [params];\n  });\n}\n\n/**\n * Cache (part of) the upload results.\n * @param result\n * @param {object} options\n * @param {string} options.type\n * @param {string} options.resource_type\n */\nfunction cacheResults(result, { type, resource_type }) {\n  if (result.responsive_breakpoints) {\n    result.responsive_breakpoints.forEach(\n      ({ transformation,\n        url,\n        breakpoints }) => Cache.set(\n        result.public_id,\n        { type, resource_type, raw_transformation: transformation, format: extname(breakpoints[0].url).slice(1) },\n        breakpoints.map(i => i.width)\n      )\n    );\n  }\n}\n\n\nfunction parseResult(buffer, res) {\n  let result = '';\n  try {\n    result = JSON.parse(buffer);\n    if (result.error && !result.error.name) {\n      result.error.name = \"Error\";\n    }\n  } catch (jsonError) {\n    result = {\n      error: {\n        message: `Server return invalid JSON response. Status Code ${res.statusCode}. ${jsonError}`,\n        name: \"Error\"\n      }\n    };\n  }\n  return result;\n}\n\nfunction call_api(action, callback, options, get_params) {\n  if (typeof callback !== \"function\") {\n    callback = function () {};\n  }\n\n  const USE_PROMISES = !options.disable_promises;\n\n  let deferred = Q.defer();\n  if (options == null) {\n    options = {};\n  }\n  let [params, unsigned_params, file] = get_params.call();\n  params = utils.process_request_params(params, options);\n  params = extend(params, unsigned_params);\n  let api_url = utils.api_url(action, options);\n  let boundary = utils.random_public_id();\n  let errorRaised = false;\n  let handle_response = function (res) {\n    // let buffer;\n    if (errorRaised) {\n\n      // Already reported\n    } else if (res.error) {\n      errorRaised = true;\n\n      if (USE_PROMISES) {\n        deferred.reject(res);\n      }\n      callback(res);\n    } else if (includes([200, 400, 401, 404, 420, 500], res.statusCode)) {\n      let buffer = \"\";\n      res.on(\"data\", (d) => {\n        buffer += d;\n        return buffer;\n      });\n      res.on(\"end\", () => {\n        let result;\n        if (errorRaised) {\n          return;\n        }\n        result = parseResult(buffer, res);\n        if (result.error) {\n          result.error.http_code = res.statusCode;\n          if (USE_PROMISES) {\n            deferred.reject(result.error);\n          }\n        } else {\n          cacheResults(result, options);\n          if (USE_PROMISES) {\n            deferred.resolve(result);\n          }\n        }\n        callback(result);\n      });\n      res.on(\"error\", (error) => {\n        errorRaised = true;\n        if (USE_PROMISES) {\n          deferred.reject(error);\n        }\n        callback({ error });\n      });\n    } else {\n      let error = {\n        message: `Server returned unexpected status code - ${res.statusCode}`,\n        http_code: res.statusCode,\n        name: \"UnexpectedResponse\"\n      };\n      if (USE_PROMISES) {\n        deferred.reject(error);\n      }\n      callback({ error });\n    }\n  };\n  let post_data = utils.hashToParameters(params)\n    .filter(([key, value]) => value != null)\n    .map(\n      ([key, value]) => Buffer.from(encodeFieldPart(boundary, key, value), 'utf8')\n    );\n  let result = post(api_url, post_data, boundary, file, handle_response, options);\n  if (isObject(result)) {\n    return result;\n  }\n\n  if (USE_PROMISES) {\n    return deferred.promise;\n  }\n}\n\nfunction post(url, post_data, boundary, file, callback, options) {\n  let file_header;\n  let finish_buffer = Buffer.from(\"--\" + boundary + \"--\", 'ascii');\n  let oauth_token = options.oauth_token || config().oauth_token;\n  if ((file != null) || options.stream) {\n    // eslint-disable-next-line no-nested-ternary\n    let filename = options.stream ? options.filename ? options.filename : \"file\" : basename(file);\n    file_header = Buffer.from(encodeFilePart(boundary, 'application/octet-stream', 'file', filename), 'binary');\n  }\n  let post_options = urlLib.parse(url);\n  let headers = {\n    'Content-Type': `multipart/form-data; boundary=${boundary}`,\n    'User-Agent': utils.getUserAgent()\n  };\n  if (options.content_range != null) {\n    headers['Content-Range'] = options.content_range;\n  }\n  if (options.x_unique_upload_id != null) {\n    headers['X-Unique-Upload-Id'] = options.x_unique_upload_id;\n  }\n  if (oauth_token != null) {\n    headers.Authorization = `Bearer ${oauth_token}`;\n  }\n\n  post_options = extend(post_options, {\n    method: 'POST',\n    headers: headers\n  });\n  if (options.agent != null) {\n    post_options.agent = options.agent;\n  }\n  let proxy = options.api_proxy || config().api_proxy;\n  if (!isEmpty(proxy)) {\n    if (!post_options.agent) {\n      if (ProxyAgent === null) {\n        throw new Error(\"Proxy value is set, but `proxy-agent` is not installed, please install `proxy-agent` module.\")\n      }\n      post_options.agent = new ProxyAgent(proxy);\n    } else {\n      console.warn(\"Proxy is set, but request uses a custom agent, proxy is ignored.\");\n    }\n  }\n\n  let post_request = https.request(post_options, callback);\n  let upload_stream = new UploadStream({ boundary });\n  upload_stream.pipe(post_request);\n  let timeout = false;\n  post_request.on(\"error\", function (error) {\n    if (timeout) {\n      error = {\n        message: \"Request Timeout\",\n        http_code: 499,\n        name: \"TimeoutError\"\n      };\n    }\n    return callback({ error });\n  });\n  post_request.setTimeout(options.timeout != null ? options.timeout : 60000, function () {\n    timeout = true;\n    return post_request.abort();\n  });\n  post_data.forEach(postDatum => post_request.write(postDatum));\n  if (options.stream) {\n    post_request.write(file_header);\n    return upload_stream;\n  }\n  if (file != null) {\n    post_request.write(file_header);\n    fs.createReadStream(file).on('error', function (error) {\n      callback({\n        error: error\n      });\n      return post_request.abort();\n    }).pipe(upload_stream);\n  } else {\n    post_request.write(finish_buffer);\n    post_request.end();\n  }\n  return true;\n}\n\nfunction encodeFieldPart(boundary, name, value) {\n  return [\n    `--${boundary}`,\n    `Content-Disposition: form-data; name=\"${name}\"`,\n    '',\n    value,\n    ''\n  ].join(\"\\r\\n\");\n}\n\nfunction encodeFilePart(boundary, type, name, filename) {\n  return [\n    `--${boundary}`,\n    `Content-Disposition: form-data; name=\"${name}\"; filename=\"${filename}\"`,\n    `Content-Type: ${type}`,\n    '',\n    ''\n  ].join(\"\\r\\n\");\n}\n\nexports.direct_upload = function direct_upload(callback_url, options = {}) {\n  let params = build_upload_params(extend({\n    callback: callback_url\n  }, options));\n  params = utils.process_request_params(params, options);\n  let api_url = utils.api_url(\"upload\", options);\n  return {\n    hidden_fields: params,\n    form_attrs: {\n      action: api_url,\n      method: \"POST\",\n      enctype: \"multipart/form-data\"\n    }\n  };\n};\n\nexports.upload_tag_params = function upload_tag_params(options = {}) {\n  let params = build_upload_params(options);\n  params = utils.process_request_params(params, options);\n  return JSON.stringify(params);\n};\n\nexports.upload_url = function upload_url(options = {}) {\n  if (options.resource_type == null) {\n    options.resource_type = \"auto\";\n  }\n  return utils.api_url(\"upload\", options);\n};\n\nexports.image_upload_tag = function image_upload_tag(field, options = {}) {\n  let html_options = options.html || {};\n  let tag_options = extend({\n    type: \"file\",\n    name: \"file\",\n    \"data-url\": exports.upload_url(options),\n    \"data-form-data\": exports.upload_tag_params(options),\n    \"data-cloudinary-field\": field,\n    \"data-max-chunk-size\": options.chunk_size,\n    \"class\": [html_options.class, \"cloudinary-fileupload\"].join(\" \")\n  }, html_options);\n  return `<input ${utils.html_attrs(tag_options)}/>`;\n};\n\nexports.unsigned_image_upload_tag = function unsigned_image_upload_tag(field, upload_preset, options = {}) {\n  return exports.image_upload_tag(field, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};\n\n\n/**\n * Populates metadata fields with the given values. Existing values will be overwritten.\n *\n * @param {Object}   metadata   A list of custom metadata fields (by external_id) and the values to assign to each\n * @param {Array}    public_ids The public IDs of the resources to update\n * @param {Function} callback   Callback function\n * @param {Object}   options    Configuration options\n *\n * @return {Object}\n */\nexports.update_metadata = function update_metadata(metadata, public_ids, callback, options = {}) {\n  return call_api(\"metadata\", callback, options, function () {\n    let params = {\n      metadata: utils.encode_context(metadata),\n      public_ids: utils.build_array(public_ids),\n      timestamp: utils.timestamp(),\n      type: options.type\n    };\n    return [params];\n  });\n};\n"]},"metadata":{},"sourceType":"script"}